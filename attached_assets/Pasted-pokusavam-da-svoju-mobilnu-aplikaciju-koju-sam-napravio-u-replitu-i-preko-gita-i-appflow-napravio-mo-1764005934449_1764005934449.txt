pokusavam da svoju mobilnu aplikaciju koju sam napravio u replitu i preko gita i appflow napravio mobilnu aplikaciju i pokusavam da je povezem na firebase messaging. aplikacija se koristi za pracenje reklamacija u jednom hotelu, vise korisnika koristi, na primjer recepcioner se uloguje da prijavi reklamaciju koja posle dodje do radnika koji treba preko push notifikacije da pobije obavjestenje da mu je na njegov nalog stigla poruka. podatke skladistim supabase i nikako da napravim da se fcm_token popuni kada se uuloguje novi korisnik...
Gemini said
Zdravo! Razumem da pokušavate da integrišete Firebase Cloud Messaging (FCM) u svoju mobilnu aplikaciju za praćenje reklamacija u hotelu, i da imate poteškoća sa povezivanjem FCM tokena sa korisnicima, posebno kada se novi korisnik prijavi. To je čest izazov, ali rešiv!
Srž problema je u tome što je FCM token jedinstven za instalaciju aplikacije na određenom uređaju, a ne za samog korisnika. To znači da ako korisnik ima više uređaja ili ponovo instalira aplikaciju, dobiće novi token. Da bi vaš sistem ispravno funkcionisao, morate:
Dohvatiti FCM token na klijentskoj strani (u vašoj mobilnoj aplikaciji).
Povezati taj token sa ID-om korisnika u vašoj bazi podataka (Supabase).
Održavati tokene ažurnim , jer se oni mogu promeniti.
Evo kako to možete postići:
1. Dohvatanje FCM tokena na klijentskoj strani

Kada se vaša aplikacija pokrene ili kada se korisnik uspešno prijavi, treba da dohvatite FCM token. Budući da vaša aplikacija koristi Replit, Git i Appflow, pretpostavljam da je bazirana na web tehnologijama (npr. Capacitor, Ionic) ili da koristite JavaScript/TypeScript.
Primer koda (JavaScript/TypeScript za mobilnu/web aplikaciju):

Prvo, proverite da li ste inicijalizovali Firebase u svojoj aplikaciji. Zatim, možete dohvatiti token ovako:
import { initializeApp } from "firebase/app";
import { getMessaging, getToken } from "firebase/messaging";
// Možda će vam trebati i vaš Supabase klijent
import { createClient } from '@supabase/supabase-js';

// --- Firebase konfiguracija (iz vašeg Firebase projekta hgbtapp) ---
const firebaseConfig = {
  apiKey: "YOUR_API_KEY", // Zameni sa stvarnim API ključem
  authDomain: "hgbtapp.firebaseapp.com",
  projectId: "hgbtapp",
  storageBucket: "hgbtapp.appspot.com",
  messagingSenderId: "375153203002",
  appId: "YOUR_APP_ID", // ID vaše Android ili Web aplikacije
};

// Inicijalizacija Firebase
const app = initializeApp(firebaseConfig);
const messaging = getMessaging(app);

// --- Supabase konfiguracija ---
const supabaseUrl = 'YOUR_SUPABASE_URL'; // Zameni sa Supabase URL-om
const supabaseAnonKey = 'YOUR_SUPABASE_ANON_KEY'; // Zameni sa Supabase anon ključem
const supabase = createClient(supabaseUrl, supabaseAnonKey);


async function registerFCMTokenForUser(userId) {
  try {
    // Proveri dozvolu za notifikacije (prvo pitaj korisnika)
    const permission = await Notification.requestPermission();
    if (permission === 'granted') {
      console.log('Notification permission granted.');

      // Dohvati FCM token
      const currentToken = await getToken(messaging, { vapidKey: 'YOUR_VAPID_KEY_HERE' });
      // VAPID ključ se nalazi u Firebase Console -> Project settings -> Cloud Messaging tab

      if (currentToken) {
        console.log('FCM token:', currentToken);

        // Sačuvaj token u Supabase i poveži ga sa korisnikom
        // Pretpostavimo da imate tabelu 'user_device_tokens' sa 'user_id' i 'fcm_token'
        const { data, error } = await supabase
          .from('user_device_tokens')
          .upsert(
            { user_id: userId, fcm_token: currentToken, device_type: 'mobile-app' },
            { onConflict: 'fcm_token' } // Ažurira postojeći ako je fcm_token već u bazi
          );

        if (error) {
          console.error('Error saving FCM token to Supabase:', error.message);
        } else {
          console.log('FCM token saved/updated successfully for user:', userId);
        }
      } else {
        console.log('No registration token available. Request permission to generate one.');
      }
    } else {
      console.log('Notification permission denied.');
    }
  } catch (err) {
    console.error('An error occurred while retrieving token or requesting permission:', err);
  }
}

// Pozovi ovu funkciju nakon uspešne prijave korisnika
// Na primer, kada dobijete user ID nakon Supabase autentifikacije
supabase.auth.onAuthStateChange(async (event, session) => {
  if (event === 'SIGNED_IN' && session?.user) {
    console.log('User signed in:', session.user.id);
    await registerFCMTokenForUser(session.user.id);
  }
  // Moguće je i rukovati SIGNED_OUT eventom za brisanje tokena
});

// Takođe, slušajte za refresh tokena (za Web)
// Za Android/iOS, token se obično automatski ažurira putem SDK-a,
// a novi token se dobija putem FirebaseMessagingService onNewToken() callback-a.
// Ako koristite hibridni pristup, vaš plugin bi trebalo da ovo radi za vas.
// Za Web:
// onMessage(messaging, (payload) => {
//   console.log('Message received in foreground.', payload);
//   // Ovde možete ažurirati UI
// });

// onBackgroundMessage (za Web service worker) je za obradu poruka kada je aplikacija u pozadini
Objašnjenje:
getToken : Ova funkcija dohvaća jedinstveni FCM token za trenutnu instalaciju vaše aplikacije.
VAPID ključ: Za web aplikacije, VAPID ključ je neophodan za autorizaciju slanja push notifikacija. Pronađite ga u Firebase konzoli pod Project settings -> Cloud Messaging tabom.
registerFCMTokenForUser(userId) : Ovu funkciju treba pozvati nakon što se korisnik uspešno prijavi i vi dobijete njegov userId iz Supabase-a.
supabase.from('user_device_tokens').upsert(...) : Ovo je ključni deo. Kreirajte tabelu u Supabase (npr. user_device_tokens ) sa kolonama user_id (koji se odnosi na vašu tabelu korisnika), fcm_token i, opciono, device_type (npr. 'android', 'ios', 'web') i timestamp_last_updated . upsert će ili ubaciti novi token ili ažurirati postojeći ako fcm_token već postoji, sprečavajući duplikate i osiguravajući da uvek imate najnoviji token za taj uređaj.
onAuthStateChange : Supabase Auth funkcija koja vam omogućava da reagujete na promene u statusu autentifikacije korisnika, idealno mesto za pozivanje registerFCMTokenForUser .
2. Slanje notifikacija sa vašeg backenda (ili Firebase Cloud Functions)

Kada imate tabelu user_device_tokens u Supabase-u, možete da pošaljete notifikacije. Kada recepcioner kreira reklamaciju, vaš backend (npr. Cloud Function, Node.js server) treba da:
Identifikuje radnika kome je namenjena reklamacija.
Izvuče sve FCM tokene povezane sa tim radnikom iz Supabase tabele user_device_tokens .
Koristi Firebase Admin SDK da pošalje poruku na te tokene.
Primer slanja notifikacije (Node.js sa Firebase Admin SDK):

// Na vašem backendu (npr. Firebase Cloud Function ili Node.js server)
import * as admin from 'firebase-admin';

// Inicijalizacija Firebase Admin SDK
// U Cloud Functions se ovo automatski radi, za Node.js server moraćete da preuzmete credencijale
admin.initializeApp();

const db = admin.firestore(); // Primer ako koristite Firestore, inače prilagodite za Supabase

async function sendNewComplaintNotification(workerId, complaintDetails) {
  // Dohvati tokene radnika iz Supabase-a
  const { data: deviceTokens, error } = await supabase
    .from('user_device_tokens')
    .select('fcm_token')
    .eq('user_id', workerId);

  if (error) {
    console.error('Error fetching worker tokens from Supabase:', error.message);
    return;
  }

  const registrationTokens = deviceTokens.map(row => row.fcm_token);

  if (registrationTokens.length > 0) {
    const message = {
      notification: {
        title: 'Nova Reklamacija!',
        body: `Imate novu reklamaciju: ${complaintDetails.description}`,
      },
      data: {
        complaintId: complaintDetails.id,
        // Dodajte druge podatke koje želite da prosledite aplikaciji
      },
      tokens: registrationTokens, // Slanje na listu tokena
    };

    try {
      const response = await admin.messaging().sendEachForMulticast(message);
      console.log('Successfully sent message:', response);

      // Opcionalno: rukovanje neuspelim tokenima (npr. brisanje iz baze)
      if (response.failureCount > 0) {
        const failedTokens = [];
        response.responses.forEach((resp, idx) => {
          if (!resp.success) {
            failedTokens.push(registrationTokens[idx]);
          }
        });
        console.log('Tokens that caused failures:', failedTokens);
        // Ovde biste mogli da obrišete nevažeće tokene iz vaše Supabase tabele
      }

    } catch (error) {
      console.error('Error sending message:', error);
    }
  } else {
    console.log('No FCM tokens found for worker:', workerId);
  }
}

// Primer poziva kada se kreira nova reklamacija
// sendNewComplaintNotification('WORKER_USER_ID', { id: 'COMPLAINT_001', description: 'Curenje vode u sobi 302' });
Tri ključna saveta:

Zatražite dozvolu za notifikacije: Uvek tražite dozvolu od korisnika pre nego što pokušate da dobijete FCM token.
Održavajte tokene: Postavite logiku na vašem backendu da periodično proverava validnost tokena i uklanja nevažeće. Firebase Admin SDK će vam reći koji su tokeni nevažeći.
Testirajte temeljno: Testirajte slanje notifikacija u različitim scenarijima (aplikacija u prvom planu, u pozadini, zatvorena).
Ovim pristupom, svaki put kada se korisnik prijavi na bilo kom uređaju, token tog uređaja će biti povezan sa njegovim nalogom u Supabase-u, omogućavajući vam da mu šaljete ciljane notifikacije.
Da biste ovo dalje istražili, možda biste želeli da pitate:
Kako da obradim FCM poruke unutar svoje mobilne aplikacije (foreground i background) nakon što stignu?
Koja je najbolja praksa za rukovanje isteklim ili nevažećim FCM tokenima na backendu?
Kako da osiguram da su moji Supabase upiti za spremanje FCM tokena sigurni i optimizovani?